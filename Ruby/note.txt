Beginning_Ruby_From_Novice_to_Professional

-   Chapter 2 Programming == JOY: A Whistle-stop tour of Ruby and Object
    Orientation

    -   irb - interactive ruby. It is like a cmd line terminal program.

        irb(main):001:0> class Person
        irb(main):002:1> attr_accessor :name, :age, :gender
        irb(main):003:1> end
        => nil
        irb(main):004:0>        

        Note: Ruby knew that you were now within a class structure, defining
        a class, rather than typing code to be processed immediately. The
        1 represents that you're at a depth of 1 of nested concepts.

        defining a class results in no return value, and nil is Ruby's
        way of representing "nothing".
        

    -   define a class example code:

        class Person
            attr_accessor :name, :age, :gender
        end

        Note:   1)  Class names in Ruby always start with a capital letter
                2)  attr stands for "attribute" and accessor roughly means
                    "make these attributes accessible to be set and changed
                    at will"
                3)  end line mathes up the class definition

    -   Basic of using a class

        -   Create an object
        
            person_instance = Person.new

        -   Set attributes

            person_instance.age = 52

        -   Print attributes

            puts person_instance.name

        -   Inheritance

            class Pet
                attr_accessor :name, :age, :gender, :color
            end

            class Cat < Pet
            end

            class Dog < Pet
            end

            class Snake < pet
                attr_accessor :length
            end

            note: length is the attribte that isn't relevant to
            every animal.

        -   Methods

            -   How to add a method to a class:

                class Dog < Pet
                    def bark
                        puts "Woof!"
                    end
                end

            -   How to use the method?

                irb(main):0> a_dog = Dog.new
                irb(main):0> a_dog.bark

            -   Passing Data to Methods

                Kernel.puts "Hello, world"

                or

                Kernel.puts("Hello, world!")

                note:

                1)  puts ia a method of the Kernel module that is included
                    and searched by default, so usually you won't need to
                    use Kernel.puts to refer to it.

                2)  Parentheses are not strictly necessary. Often, however
                    , parentheses are required, as in many situation
                    omitting them leaves the code vague and imprecise.

        -   Which class am I?

            e.g. puts 2.class => Fixnum

    -   Everything in Ruby is an object        

        puts 1 + 10

        In the above statement, even 1 and 10 are objects of class Fixnum

    -   String related methods:

        Expression                  Output

        "Test" + "Test"	            TestTest
        "Test".capitalize	        Test
        "Test".downcase	            test
        "Test".chop	                Tes
        "Test".next	                Tesu
        "Test".reverse	            tseT
        "Test".sum	                416
        "Test".swapcase	            tEST
        "Test".upcase	            TEST
        "Test".upcase.reverse	    TSET
        "Test".upcase.reverse.next	TSEU

-   Chapter 3   Ruby's Building Blocks: Data, Expressions, and Flow Control

    -   Examples

        -   if statement

            age = 24
            puts "You're a teenager" if age > 12 && age < 20

        -   unless statement

            age = 24
            puts "You're NOT a teenager" unless age > 12 && age < 20

        -   x <=> y

            x <=> y means Comparison; return 0 if x and y are equal, 1 if x is higher, and -1 if y is higher

    -   Looping Through Numbers with Blocks and Iterators

        -   Fixnum.times method

            5.times do puts "Test" end

            or

            5.times {puts "Test"}

            note: parentheses are used to replace the "do end" couple.

            In Ruby, one mechanism to create a loop is called an iterator. An iterator is something that progresses through a list
            of items one by one. E.g.

            1.upto(5) { ...code to loop here... }
            10.downto(5) { ...code to loop here... }
            0.step(50, 5) { ...code to loop here... }

            The first and second examples are self-explainatory. The third example counts up from 0 to 50 in steps of 5

            How to get hold of the number being iterated upon at each step of the way so that you can do something with it in the looped
            code. What if you wanted to print out the current iteration number? Thanksfully, all of the iterators just explained automatically
            pass the state of the iteration to the looped code as a parameter, which you can then retrieve into a variable and use, like:

            1.upto(5) {|number| puts number}

            |number| is the way how a parameters are passed into blocks of code that don't have specific names. Another way of writing the above
            block of code is like:

            1.upto(5) do |number|
                puts number
            end
     
        -   Constants

            Any variable beginning with a capital letter, for example:

            Pi = 3.141592

        -   Text and Strings

            -   Assigning String value

                The simlest form of assigning a string value is:
            
                x = "Test"
                y = "String"
                puts "Success!" if x + y == "TestString"

                There are several other ways of including a string literal within a program. If you want to include multiple lines of text, try this:

                x = %q{This is a test
                of the multi
                line capabilities}

                You don't have to use curly brackets, anything pairs of symbols for example: < and >, ( and ) or simply two other delimiters of your choice
                such as ! and !.

                Another way to build up a long string literal is by using a "here document". The concept is very similar to the previous example, except that
                the delimiter can be many characters long. Here's an example:

                x = <<END_MY_STRING_PLEASE
                This is the string
                And a second line
                END_MY_STRING_PLEASE

            -   String Expressions

                -   1) puts "abc" * 5
                    "abcabcabcabcabc"

                -   2) puts "x" > "y"
                    false

                -   3) if you are interested to learn what value a particular character has, find out like so:

                    puts "x".ord
                    120

                -   4) A reverse method for above statement

                    puts 120.chr
                    x

                -   Interpolation

                    You can embed expressions (and even logic ) directly into strings. This is so called interpolation. The way of interpolate
                    a string is to place the expression within #{and} symbols. E.g.

                    puts "100 * 5" = #{100 * 5}"

                    The #{100 * 5} section interpolates the result of 100 * 5(500) into the string at that position, resulting in th output shown.

                    Another example to demo this concept is:

                    puts "It's a #{"bad " * 5 }"

                -   Other string methods

                    Expression                  Output                    

                    "Test" + "Test"	            TestTest
                    "Test".capitalize	        Test
                    "Test".downcase	            test
                    "Test".chop	                Tes
                    "Test".next	                Tesu
                    "Test".reverse	            tseT
                    "Test".sum	                416
                    "Test".swapcase	            tEST
                    "Test".upcase	            TEST
                    "Test".upcase.reverse	    TSET
                    "Test".upcase.reverse.next	TSEU
                    "Test".length               4

            -   Regular expression and String Manipulation

                A regular expression is a string that describes a pattern for matching elements in other strings.

                -   Subsitutions

                    puts "foobar".sub('bar', 'foo')
                    foofoo

                    The above example demo a single sub. For multiple sub, look at the below example:

                    puts "this is a test".gsub('i', '')
                    ths s a test
                                       
                    For more complicated examples such as to replace the first two characters of a string with 'Hello'

                    puts "this is a test.gsub(/^../, "Hello")"
                    Hellois is a test
            
                    The ^ is an anchor, meaning the regular expression will match from the beginning of any lines within the string
                    The two periods each represent “any character.” In all, /^../ means “any two characters immediately after the 
                    start of a line.”

                    Likewise, if you want to change the last two characters, you can use a different anchor:

                    x = "This is a test"
                    puts x.sub(/..$/, 'Hello')
                    This is a teHello

                -   Iteration with a regular Expression

                    What if you want to iterate through a string and have access to each section of it
                    separately? scan is the iterator method you require:

                    "xyz".scan(/./) { |letter| puts letter }
                    x
                    y
                    z

                    Another example to demo to iterate through every two characters:

                    "This is a test".scan(/../) {|x| puts x}
                    
                    Th
                    is
                     i
                    s 
                    a 
                    te
                    st

                    The result is weird with all spaces mixed in. Let's adjust our regular expression to match only letters and digits, like so:
                    
                    "This is a test".scan(/\w\w/) { |x| puts x }

                    Th
                    is
                    is
                    te
                    st

                    \w means “any alphanumeric character or an underscore.

                    Character   Meaning

                    ^	        Anchor for the beginning of a line
                    $	        Anchor for the end of a line
                    \A	      Anchor for the start of a string
                    \Z	      Anchor for the end of a string
                    .	        Any character
                    \w	      Any letter, digit, or underscore
                    \W	      Anything that \w doesn’t match
                    \b        Matches word boundaries when outside brackets; backspace (0x08) when inside brackets
                    \B        Matches non-word boundaries
                    \d	      Any digit
                    \D	      Anything that \d doesn’t match (non-digits)
                    \s	      Whitespace (spaces, tabs, newlines, and so on)
                    \S	      Non-whitespace (any visible character)

                    Another example:

                    "The car costs $1000 and the cat costs $10".scan(/\d+/) do |x|
                    puts x
                    end

                    1000
                    10
                    
                    The + that follows \d makes \d match as many digits in a row as possible. '+' after a character in a regular expression means 
                    match one or more of that type of character. There are other types of modifiers, and these are shown below:

                    Modifier	        Description
                    *	                Match zero or more occurrences of the preceding character, and match as many as possible.
                    +	                Match one or more occurrences of the preceding character, and match as many as possible.
                    *?	                Match zero or more occurrences of the preceding character, and match as few as possible.
                    +?	                Match one or more occurrences of the preceding character, and match as few as possible.
                    ?	                Match either one or none of the preceding character.
                    {x}	                Match x occurrences of the preceding character.
                    {x,y}	            Match at least x occurrences and at most y occurrences.

                    Last but not least, you can use "character classes" to match against a specific set of characters. E.g.

                    "This is a test".scan(/[aeiou]/) { |x| puts x }

                    i
                    i
                    a
                    e

                    another example: 

                    "This is a test".scan(/[a-m]/) { |x| puts x }
                    
                    h
                    i
                    i
                    a
                    e

                -   Matching
                
                    Making substitions and extracting certain text from strings is useful, but sometimes you merely want to check whether a certain string
                    matches against the pattern of your choice. Let's look at one example:

                    puts "String has vowels" if "This is a test" =~ /[aeiou]/
                
                    =~ is another form of operator: a matching operator. If the string has a match with the regular expression following the operator, then 
                    the expression returns the position of the first match.
        
                    It's possible to use a method called match, provided by the String class. Match can provide more power than =~. Here is an example:

                    puts "String has vowels" if "This is a test".match(/[aeiou]/)

                    In regular expressions, if you surround a section of the expression with parentheses - ( and ) - the data matched by that section of the
                    regular expression is made available separately from the rest.match lets you access the data(??):

                    x = "This is a test".match(/(\w+) (\w+)/)
                    puts x[0]
                    puts x[1]
                    puts x[2]

                    This is
                    This
                    is

                    match returns a MatchData object that can be accessed like an array. The first element
                    (x[0]) contains the data matched by the entire regular expression. However, each successive
                    element contains that which was matched by each match group of the regular expression. In
                    this example, the first (\w+) matched This and the second (\w+) matched is.


        -   Arrays and Lists

            x = [1, 2, 3, 4]
            puts x[2]
            
            3

            -   You can create an empty array like:

                x = []

            -   Push data into an array

                x << "Word"
                
                After this, the array contains a single element: a string saying "Word". << is the operator for pushing an item into the end of an array. You can
                also use the push method: 

                x.push("Word")

            -   Remove entries from arrays

                x = []
                x << "Word"
                x << "Play"
                x << "Fun"
                puts x.pop
                puts x.pop
                puts x.length

                Fun
                Play
                1

            -   If array is full of strings, you can join all the elements together into one big string by calling the join method on the array:

                x = ["Word", "Play", "Fun"]
                puts x.join

                WordPlayFun

                or 

                x = ["Word", "Play", "Fun"]
                puts x.join(', ')

                Word, Play, Fun

            -   Splitting Strings into Arrays

                You can use the split method to split a string into multiple pieces. Like so:

                puts "Short sentence. Another. No more.".split(/\./).inspect

                ["Short sentence", " Another", " No more"]

                Note:

                1)      In the regular expression rather than ., you'd be splitting on every character rather than on full stops, 
                        because . represents "any character" in a regular expression. Therefore, you have to escape(escaping is
                        process of specifically denoting a character to make its meaning clear) it by prefixing it with a backslash; 

                2)      The inspect method is common to almost all built-in classes in Ruby and it gives you a textual representation 
                        of the object. You can use 'p' to replace inspect. E.g.
    
                        p "Words with lots of spaces".split(/\s+/)

                        ["Words", "with", "lots", "of", "spaces"]

            -   Array Iteration

                -   example 1: use "each" method

                    [1, "test", 2, 3, 4].each { |element| puts element.to_s + "X" }

                    1X
                    testX
                    2x
                    3x
                    4x

                -   example 2: use "collect" method

                    Although each iterates through elements of an array, you can also convert an array on the fly using the collect method:

                    [1, 2, 3, 4].collect { |element| element * 2 }

                    [2, 4, 6, 8]

                    collect iterates through an array element by element, and assigns to that element the result of any expression within the code block.

                    note: map function is the same as collect

                -   example 3: use the regular method

                    while (i < a.length)
                      puts a[i].to_s + "X"
                      i += 1
                    end
                

            -   Other array methods

                -   Addition +

                    x = [1, 2, 3]
                    y  = ["a", "b", "c"]
                    z = x + y
                    p z

                    [1, 2, 3, "a", "b", "c"]

                -   Subtraction -

                    x = [1, 2, 3, 4, 5]
                    y = [1, 2, 3]
                    z = x - y
                    p z

                    [4, 5]

                -   empty array check

                    x = []
                    puts "x is empty" if x.empty?

                    x is empty

                -   checking an Array for a Certain item
                                        
                    x = [1, 2, 3]
                    p x.include?("x")
                    p x.include?(3)

                    false
                    true

                -   Accessing the first/last element of the array

                    x = [1, 2, 3]
                    puts x.first
                    puts x.last

                    1
                    3

                    x = [1, 2, 3]
                    puts x.first(2).join("-")

                    1-2

                -   Reversing the order

                    x = [1, 2, 3]
                    p x.reverse
    
                    [3, 2, 1]

        -   Hashes

            directionary = {'cat' => 'feline animal', 'dog' => 'canine animal'}

            puts directionary.size
            
            2

            -   Basic Hash Methods

                -   Iterate through Hash Elements

                    x = { "a" => 1, "b" => 2 }
                    x.each { |key, value| puts "#{key} equals #{value}" }

                    a equals 1
                    b equals 2

                    In Ruby 1.8, there is no guarantee that elements will be returned in a specific order. In Ruby 1.9,
                    however, the order in which the elements were inserted into the hash will be remembered, and each will
                    return them in that order.

                -   Retrieving keys

                    x = { "a" => 1, "b" => 2, "c" => 3 }
                    p x.keys

                    ["a", "b", "c"]

                -   Delete Hash Elements

                    x = { "a" => 1, "b" => 2 }
                    x.delete("a")
                    p x

                    {"b"=>2}

                -   Deleting Hash Elements Conditionally
                    
                    x = { "a" => 100, "b" => 20 }
                    x.delete_if { |key, value| value < 25 }
                    p x

                    {"a"=>100}

            -   Hash Within Hashes

                people = {
                    'fred' => {
                        'name' => 'Fred Elliott',
                        'age' => 63,
                        'gender' => 'male',
                        'favorite painters' => ['Monet', 'Constable', 'Da Vinci']
                    },
                    'janet' => {
                        'name' => 'Janet S Porter',
                        'age' => 55,
                        'gender' => 'female'
                    }
                }

                puts people['fred']['age']
                puts people['janet']['gender']
                p people['janet']

                63
                female
                {"name"=>"Janet S Porter", "gender"=>"female", "age"=>55}

                Even the array embedded within Fred’s hash is easy to access:
                puts people['fred']['favorite painters'].length
                puts people['fred']['favorite painters'].join(", ")

                3
                Monet, Constable, Da Vinci

            -   Flow Control

                -   if and unless
                -   ? the Ternary Operator
                -   elsif and case

                    fruit = "orange"
                    if fruit == "orange"
                        color = "orange"
                    elsif fruit == "apple"
                        color = "green"
                    elsif fruit == "banana"
                        color = "yellow"
                    else
                        color = "unknown"
                
                    fruit = "orange"
                    case fruit
                        when "orange"
                        color = "orange"
                        when "apple"
                        color = "green"
                        when "banana"
                        color = "yellow"
                        else
                        color = "unknown"
                    end

                    You can use another trick to shorten the above example:

                    fruit = "orange"
                    color = case fruit
                      when "orange"
                      "orange"
                      when "apple"
                      "green"
                      when "banana"
                      "yellow"
                      else
                      "unknown"
                    end

                -   while and until

                    x = 1
                    until x > 99
                      puts x
                      x = x * 2
                    end

                    It's also possible to while and until in a single line setting:

                    i = 1
                    i = i * 2 until i > 1000
                    puts i

                    1024

                -   Code Blocks

                    The code between { and } or do and end is a code block. Another example(!!)

                    def each_vowel(&code_block)
                      %w{a e i o u}.each { |vowel| code_block.call(vowel) }
                    end

                    each_vowel { |vowel| puts vowel }

                    a
                    e
                    i
                    o
                    u

                    each_vowel is a method that accepts a code block, as designated by the ampersand(&) before the variable name code_block in the method
                    definition. It then iterates over each vowel in the literal array %w{a e i o u} and uses the call method on code_block to execute
                    the code block for each vowel, passing in the vowel variable as a parameter each time. 

                    Note: Code blocks passed in this way result in objects that have many methods of their own, such as "call".

                    Another alternate technique is to use the yield method, which automatically detects any passed code block and passes control to it:

                    def each_vowel
                      %w{a e i o u}.each { |vowel| yield vowel}
                    end

                    each_vowel {|vowel| puts vowel }

                    The last method you can use is to store code blocks within variable, using the lambda method:

                    print_parameter_to_screen = lambda { |x| puts x }
                    print_parameter_to_screen.call(100)

                    100

                -   Other Useful Building Blocks
    
                    -   Dates and Times
                    -   Large Numbers
                    -   Ranges

                        x = ['A', 'B', 'C'..., 'Z'] can be written as a representation of a range

                        ('A'..'Z')

                        The Range class provides a simple way to convert a range into an array with to_a:

                        ('A'..'Z').to_a.each{|letter| print letter}

                        ABCDEFGHIJKLMNOPQRSTUVWXYZ=> 
                        ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

                        You can check if R is within the range, using the include? method, like so:

                        ('A'..'Z').include?('R')

                        => true

                    -   Symbols

                        current_situation = :good
                        puts "Everything is fine" if current_situation == :good
                        puts "PANIC!" if current_situation == :bad

                        => Everything is fine

                        Here :good and :bad are symbols. 

                        Symbols don’t contain values or objects, like variables do. Instead, they’re used as a consistent 
                        name within code. For example, in the preceding code, you could easily replace the symbols with strings, like so:

                        current_situation = "good"
                        puts "Everything is fine" if current_situation == "good"
                        puts "PANIC!" if current_situation == "bad"

                        This gives the same result, but isn’t as efficient. In this example, every mention of “good”
                        and “bad” creates a new object stored separately in memory, whereas symbols are single refer-
                        ence values that are only initialized once. In the first code example, only :good and :bad exist,
                        whereas in the second example, you end up with the full strings of "good", "good", and "bad"
                        taking up memory.

                        You might want to consider symbols to be literal constants that have no value, but whose
                        name is the most important factor.

                        Symbols are particularlu useful when creating hashes and you want to have a distinction between keys and values. E.g.

                        s = { :key => 'value' }
            
                        This technique can also be useful when there’s a specification or consistency in which key
                        names to use:

                        person1 = { :name => "Fred", :age => 20, :gender => :male }
                        person2 = { :name => "Laura", :age => 23, :gender => :female }


-  Chapter 4 Your first Ruby program 

    -   Please check myFirst.rb, summarize.rb, and argv.rb in the test folder

-  Chapter 6 Classes, Objects and Modules

    -   Return Statement

        It's not necessary to use return to return values from methods in Ruby. The last expression within the method is used as the return bu default.
        If it feels right for the situation or seems clearer to you, however, you can certainly use return with impunity!

    -   Local, Global, Object and Class Variables

        -   Local variables

            def basic_method
                x = 50
                puts x
            end

        -   Global variables

            def basic_method
            puts $x
            end

        -   Object Variables

            class Square
                def initialize(side_length)
                    @side_length = side_length
                end
                def area
                    @side_length * @side_length
                end
            end

            a = Square.new(10)
            b = Square.new(5)
            puts a.area
            puts b.area

            100
            25

        -   Class Variables

            class Square
                def initialize
                    if defined?(@@number_of_squares)
                        @@number_of_squares += 1
                    else
                        @@number_of_squares = 1
                    end
                end
                
                def self.count
                    @@number_of_squares
                end
            end

            a = Square.new
            b = Square.new
            puts Square.count

            2

        -   Object methods vs Class methods

            "self." is used to denote a class method. Please see test/Square.rb for more detail.

        -   Inheritance

            "<" is used to inherit from a parent class. Pls refer to test/parent.rb for more detail.

        -   Reflection and Discovering an Object's Methods

            Reflection is the process by which a computer program can inspect, analyze, and modify itself while
            it's running and being used. Ruby takes reflection to an extreme, and allows you to change the functionality 
            of great swathes of the language itself while running your own code.

            -   methods() method
        
                a = "This is a test"
                puts a.methods.join(' ')

                The methods method on any object (unless it has been overridden, of course!) returns an array of methods made 
                available by that object.

            -   instance_variables

                It returns the names of any object
                variables associated with an instance (as opposed to class variables):

                class Person
                  attr_accessor :name, :age
                end

                p = Person.new
                p.name = "Fred"
                p.age = 20
                puts p.instance_variables

                ["@age", "@name"]

                note: Ruby 1.9’s implementation of instance_variables returns symbols that refer to the object
                variables rather than strings.

            -   Encapsulation

                Encapsulation is the ability for an object to have certain methods and attributes available for
                use publicly (from any section of code), but for others to be visible only within the class itself
                or by other objects of the same class.

                class Person
                def anyone_can_access_this
                   ...
                end
                
                    private
                    def this_is_private
                       ...
                    end
                    
                    public
                    def another_public_method
                       ...
                    end
                end

                You can also use "private" as a command by passing in symbols representing the methods you want to keep private, like so:

                class Person
                    def anyone_can_access_this; ...; end
                    def this_is_private; ...; end
                    def this_is_also_private; ...; end
                    def another_public_method; ...; end
                    private :this_is_private, :this_is_also_private
                end

                The third form of encapsulation (other than public and private) called protected that makes a method private, but within
                the scope of a class rather than within a single object(??It seems this is different from the protected concept in Java/C++).
                For example, you were unable to directly call a private method outside the scope of that object and its methods. However
                , you can call a protected method from the scope of the methods of any object that's a member of the same class.

                Note:

                Note  Ruby supports ending lines of code with semicolons ( ; ) and allows you to put multiple lines of code
                onto a single line (for example, x = 10; x += 1; puts x ). In this case, it’s been done to save on lines of
                code in the example, although it’s not considered good style in production-quality Ruby code.

                For more detail, please check the person.rb in /test

            -   Polymorphism

                Polymorphism is the concept of writing code that can work with objects of multiple types and
                classes at once. Please see polymorphism.rb for more detail.

            -   Nested Classes

                Nested classes are useful when you want to seperate classes into groups of classes rather than keep them all distinct.

                class Drawing
                    def Drawing.give_me_a_circle
                        Circle.new
                    end

                    class Line
                    end
                    class Circle
                        def what_am_i
                            "This is a circle"
                        end
                    end
                end

                a.Drawing.give_me_a_circle
                puts a.what_am_i
                a = Drawing::Circle.new
                puts a.what_am_i
                #a = Circle.new
                #puts a.what_am_i

                You can create a circle object with either a.Drawing.give_me_a_circle or Drawing::Circle.new.
                But you cannot directly create a circle instance with Circle.new directly.

            -   Modules, Namespaces, and Mix-Ins
            
                Modules provide a structure to collect Ruby classes, methods, and constants into a single,
                separately named and defined unit.

                -   Namespaces
    
                    Modules help to solve name conflicts by providing namespaces that can contain any number of classes, methods,
                    and constants, and allow you to address them directly. Please see the modules.rb as an example.

                -   Max-Ins

                    Ruby doesn't support multiple inheritance. However, in some cases, it can be useful to share functionality 
                    between disparate classes. In this sense, modules act like a sort of “super” class and can be included into other classes,
                    extending that class with the methods the module offers. Please see mixIns.rb for more detail.

                Two keywords:   1) module;  2) include

                module is used to define a module to include classes, methdos and constants.
                include takes a module and includes its contents into the current scope.

                Ruby comes with several modules by standard that you can use. E.g. the Kernel module contains all the "standard" commands (such as load, 
                require, exit, puts, eval...) without getting involved with objects or classes. Two such modules are Enumerable and Comparable.

- Chapter 7 Projects and Libraries

    -   Basic File Inclusion

        You might want to write a number of methods to add to String that you'd like to use in multiple programs. Rather than copy and paste the code each time
        you can copy it out to a separate file and use the require command to load the external file into the current program. For example, put this code in 
        a file called string_extensions.rb:

        class String
          def vowels
            self.scan(/[aeiou]/i)
          end
        end

        and Put this code in a file called vowel_test.rb:

        require 'string_extensions'
        puts "This is a test".vowels.join('-')

        You can also use "load" to load external source-code files into your program. For example:

        load 'string_extensions.rb'
        puts "This is a test".vowels.join('-')

        (!!)Note: load requires a full filename, including the .rb suffix, whereas require assume the .rb suffix.
        Also, With load, the code is loaded and reprocessed anew each time you use the load method. require, on the
        other hand, processes external code only once. Good Ruby programmers usually prefer using "require" instead
        of "load"

    -   Inclusions from Other Directories

        Ruby stores the list of directories to search for included files in a special variable called $:
        (or, if you prefer, $LOAD_PATH). You can see what $: contains by default, using irb:
        $:.each { |d| puts d }

        /usr/local/lib/site_ruby/1.9.1
        /usr/local/lib/site_ruby/1.9.1/x86_64-linux
        /usr/local/lib/site_ruby
        /usr/lib/ruby/vendor_ruby/1.9.1

        If you want to add extra directories to this, 

        $:.push '/your/directory/here'
        require 'yourfile'

        Note: $: is an array so you can do "push" operation

    -   Logic and Including Code

        -   Example 1:

            $debug_mode = 0
            require $debug_mode == 0 ? "normal-classes" : "debug-classes"

        -   Example 2:

            %w{file1 file2 file3 file4 file5}.each { |l| require l }

    -   Libraries

        -   RubyGems(!!)

            RubyGems is a packaging system for Ruby programs and libraries. It enables developers to package their Ruby libraries 
            in a form that's easy for users to maintain and install. RubyGems makes it easy to manage different versions of the 
            same libraries on your machine, and  gives you the ability to install them with a single line at the command prompt.

            Each individually packaged Ruby library (or application) is known simply as a gem or RubyGem. Gems have names, version 
            numbers, and descriptions. You can manage your computer’s local installations of gems using the gem command, available 
            from the command line.

            -   Finding Gems

                To find local gems: gem list --local

                To find remote gems: gem list --remote

                Note: The remote gem server is currently hosted by RubyForge, but you can add other source later on(??how).

                Alternatively, you can use the search features offered by the gem program directly, like so:

                gem query --remote --name-matches class

            -   Installing a Simple Gem

                sudo gem install feedtools

                or gem install hpricot --source http://code.whytheluckystiff.net

                note: --source specifies another remote source site rather than the default one such as RubyForge

            -   Using Gems

                As the RubyGems system isn’t an integrated part of Ruby, it’s necessary to tell your programs
                that you want to use and load gems.

                Let's look at one example:

                require 'rubygems'
                require 'RedCloth'
                r = RedCloth.new("this is a *test* of _using RedCloth_")
                puts r.to_html

                => <p>this is a <strong>test</strong> of <em>using RedCloth</em></p>

                In this example, you first load up the RubyGems library, and then load up the RedCloth
                library with require. When RubyGems is loaded on the first line, the RubyGems library over-
                rides the require method and enables it to be used to load gems as if they were normal, local
                libraries(!!).

            -   Updating and Uninstalling Gems

                sudo gem update
                sudo gem uninstall feedtools

-   Chapter 8 Documentation, Error Handling, Debugging, and Testing

    -   Documentation

        Ruby uses a utility called RDoc to make documentation extremely easy to document your code. For example: 

        rdoc person.rb

        This command tells RDoc to process person.rb and produce the HTML documentation. By default, it does this 
        by creating a directory called doc from the current directory and placing its HTML and CSS files in there.

        -   Basic Formatting(...)
        -   Modifier and Options(...)
        -   Command Options(...)

    -   Debugging and Errors

        -   Exceptions and Error Handling

            -   Raising Exceptions
  
                When an exception is raised (exceptions are said to be raised when they occur within the
                execution of a program), Ruby immediately looks back up the tree of routines that called
                the current one (known as the stack) and looks for a routine that can handle that particular
                exception. If it can’t find any error-handling routines, it quits the program with the raw error
                message.

                E.g.

                irb(main):001:0> puts 10 / 0

                =>

                ZeroDivisionError: divided by 0
                from (irb):1:in `/'
                from (irb):1

                You can use the keyword "raise" to generate an exception. E.g.

                class Person
                  def initialize(name)
                    raise ArgumentError, "No name present" if name.empty?
                  end
                end

                fred = Person.new('')

                => ArgumentError: No name present

                Note: Always provide a message and a class with raise , if possible.

                However, you could create your own type of exception if you wanted to. For example:

                class BadDataException < RuntimeError
                end

                class Person
                  def initialize(name)
                    raise BadDataException, "No name present" if name.empty?
                  end
                end

            -   Handling Exceptions(!!)
  
                In most situations, stopping a program because of a single error isn’t necessary.
                The error might only be minor, or there might be an alternative option to try.  

                Therefore, it’s possible to handle exceptions. In Ruby, the rescue clause is used, 
                along with begin and end, to define blocks of code to handle exceptions. For example:

                begin
                  puts 10 / 0
                rescue
                  puts "You caused an error!"
                end

                => You caused an error!

                rescue's syntax makes handling different exceptions in different ways eash:

                begin
                  ... code here ...
                rescue ZeroDivisionError
                  ... code to rescue the zero division exception here ...
                rescue YourOwnException
                  ... code to rescue a different type of exception here ...
                rescue
                  ... code that rescues all other types of exception here ...
                end

            -   Handling Passed Exceptions

                As well as handling different types of exceptions using different code blocks, it’s possible to
                receive exceptions and use them. This is achieved with a little extra syntax on the rescue block:

                begin
                  puts 10 / 0
                rescue => e
                  puts e.class
                end

                => ZeroDivisionError

            -   Catch and Throw (!!)
 
                Sometimes you want to be able to break out of a thread of execution (say, a loop) during normal operation
                in a similar way to an exception, but without actually generating an error. Ruby provides two methods, catch 
                and throw, for this purpose.

                catch(:finish) do
                  1000.times do
                    x = rand(1000)
                    throw :finish if x == 123
                  end

                  puts "Generated 1000 random numbers without generating 123!"
                end

                Within the catch block you generate 1,000 random numbers, and if the random number is
                ever 123, you immediately escape out of the block using throw :finish. However, if you man-
                age to generate 1,000 random numbers without generating the number 123, the loop and the
                block complete, and you see the message.

                Catch and throw don’t have to be directly in the same scope. throw works from methods
                called from within a catch block:

                def generate_random_number_except_123
                  x = rand(1000)
                  throw :finish if x == 123
                end

                catch(:finish) do
                  1000.times { generate_random_number_except_123 }
                  puts "Generated 1000 random numbers without generating 123!"
                end

        -   The Ruby Debugger

            ruby -r debug debugtest.rb

            Note: -r: Causes Ruby to load the library using require.

            -   Most useful commands:
  
                -   list
                -   step 
                -   cont
                -   break
                -   watch
                -   quit
                
        -   Testing 

            -   Test Driven Development
            -   Behaviol Driven Development
            -   Unit Testing

                With more than a few tests, it soon becomes messy, as there's no logical place for the tests to go and you certainly do not want to
                include tests with your actual functional code. Ruby comes with a library, Test::Unit that makes testing easy and organizes test cases
                into a clean structure. Unit testing is the primary component of test-driven development, and means that you’re testing each individual 
                unit of functionality within a program or system. Test::Unit is Ruby’s official library for performing unit tests.

            -   BenchMarking and Profiling

-   Chapter 9 Files and Databases

    -   File I/O (...)
    -   Text File Databases(...)
    -   Storing Objects and Data Structures

        -   PStore

            PStore is a core Ruby library that allows you to use Ruby objects and data structures as you
            normally would, and then store them in a file. Later on, you can reload the objects back into
            memory from the disk file. This technique is known as object persistence, and relies on a tech-
            nique called marshalling, where standard data structures are turned into a form of flat data
            that can be stored to disk or transmitted over a network for later reconstruction.


            (...)

        -   YAML (standing for YAML Ain’t Markup Language)

            It is a special text-based markup language that was designed as a data serialization format that’s readable by humans.

            (...)

    -   Relational Databases and SQL

-   Chapter 13 Web Application Frameworks: Rails, Sinatra, and Ramaze

    -   Ruby On Rails

        It's an open-source, web application framework. A framework is a set of code libraries and data-structures that provide
        generic functionality which can be used, overridden or further specilized.

        -   2 Principles

            -   DRY - "Don't repeat yourself". It means Concise, consistent code that is easy to maintain. Built DRY, encourage DRY.
            -   Convention over configuration - Sensible defaults(??), only specify unconventional aspects. It can speed development
                and less code to maintain. Extra features for free.

        -   MVC Web Architecture

                      1                   2             3 
            Browser   ->    Controller    ->    Model   -> DataBase
               ^                 |         5             4
               |                 |         <-            <-
               |7                v
               |                 6
               |----------------View (HTML, CSS, JavaScript)
            

        
            Controller: Handle Decisions
            Model:      Handle Data
            View:       Handle Presentation

            In Ruby-On-Rails, We call:

            Controller    ->    ActionController
            View          ->    ActionView
            Model         ->    ActiveRecord

            it also groups ActionController and ActionView together as ActionPack

        -   Bundler

            Two files are associated with Bundler: 1) Gemfile; 2) Gemfile.lock

            Gemfile is the file to tell Bundler which gems are needed for this project and what versions.

            Run: bundle install so that the bundler translates Gemfile into Gemfile.lock so that the bundler translates Gemfile into Gemfile.lock

            Tip:

            If running the following failed:

            rake db:migrate

            try:

            bundle exec rake db:migrate

            You can also use bundle list to list all the gems installed in your app.

        -   Create a Prject
  
            Let's take using a postgresql as our database as an example:

            rails new simple_cms -d postgresql

            There are a couple sub-folders also created for you:

            app:

            app/controllers:

            app/helpers:

            app/models:

            app/

            Now, rails creates a project called simple_cms with postgresql

        -   Configure the database

            Go to the file in /config/database.yml and setup the database setting:

            E.g.

            development:
              adapter: postgresql
              encoding: unicode
              database: aioptify
              pool: 5
              username: aioptify
              password:
            ...

    
        -   Accessing a Project

            Start web server

            rails s or rails server

            Note: You may run into the trouble: "Rails server does not start -> Could not find a JavaScript runtime"

            That means you don't have JavaScript runtime installed. Therefore, you need to do this:

            sudo add-apt-repository ppa:chris-lea/node.js
            sudo apt-get -y update
            sudo apt-get -y install nodejs

        -   public folder

            If there is an html page already exists in the public folder, no bother the Rails Framework.

        -   Routing

            -   The Purpose of the Rails Router

                The Rails router recognizes URLs and dispatches them to a controller's action. It can also
                generate paths and URLs, avoiding the need to hardcode strings in your views.

            -   Simple route

                E.g. In the folder config/routes.rb

                get "demo/index"

                The above statement is the simplified form. The long one is shown below:

                match "demo/index",
                  :to => "demo#index",
                  :via => :get

            -   Default route
        
                Simple routes are not convinent to handle many cases. It would be much better if we can write the routing rules that can
                handle many cases. They can pass the strings to the right components. This is what Default Route does. The Default route
                structure looks something like the following:

                :controller/:action/:id

                E.g.

                If an upcoming request is: "GET /students/edit/52"

                |
                v
                StudentController, edit action
                |
                v
                match ':controller(/:action(/:id))', :via => :get

                Note: the parentheses () means optional. From programming point of view; :controller, :action, :id, :via and :get are all keywords.

                Another example to show if you need JSON handling, try "format":

                match ':controller(/:action(/:id(.:format)))',
                  :via => :get
        
            -   Root route

                root :to => "demo#index" or root to: => "demo#index"
  
                The short-hand version is:

                root "demo#index" (Note: this version is not supported by Rails 3.2.16)

            -   Print the routing info:

                go to the rails root folder and run:

                rake routes

        -   Rendering Template

            -   How does the controller choose which view to display to the user?

                In each controller, it is a good practice to have each action defined. E.g.

                class DemoController < ApplicationController
                  layout false
                  def index
                    render(:template => 'demo/hello')
                  end
                  
                  def hello
                  end
                end

            -   Use the render method to tell the controller which template to load for that specified action:

                ...
                  def index
                    render(:template => 'demo/hello') #or render('demo/hello') or render('hello'), because we are in demo controller,
                                                      #we can ommit 'demo'
                ...

        -   Redirecting Actions

            A redirect means a controller directs a request to another controller. For example, a user wants to access a page that is login required. 
            The controller can direct the user to the login page. Why not just use render to the login page? Because there are other tasks to implement
            before rendering the login page such as reading the cookies.

            The syntax looks something like the following:

            redirect_to(:controller => 'demo', :action => 'index')

            or

            redirect_to('http://www.ign.com')

        -   View Templates

            -   What is ERb?

                It stands for Embedded Ruby. eRuby templating system to embed Ruby

            -   Template file naming

                hello.html.erb

                It means that:
                
                Template name: hello
                Process with: ERb
                Output format: HTML

            -   Embedding Ruby in an ERb template

                <% code %> : execute the ruby code

                < %= code% > : execute the ruby code and output the result

                E.g.

                <% 3.times do %>
                    <%= "xxx" %>
                <% end %>

                Note: To output text to html, we cannot do <% puts "xxx" %>, instead, we need to do <%= "xxx" %>

        -   Instance Variables

            You can setup a variable in your controller, inside a action that it becomes available to the corresponding view at the end. E.g.

            In your controller:
        
              def hello
                #render('demo/index')
                @array = [1, 2, 3, 4, 5]
              end

            In your view:

             <% @array.each do |n| %>
               <%= n %><br />
             <% end %>

            The reason why the view and controller can talk to each other this way because they all belong to ActionPack. Remember, you can
            pass instance variables from controller to view to the other way around!

        -   Links

            -   Rails links

                Rails's helper method:

                <%= link_to(text, target) %> 

                Target:

                    "/demo/index"

                    or

                    {:controller => 'demo', :action => 'index'}

                    or 

                    (if are in under the same controler)
            
                    {:action => 'index'}

                There is no harm if you just use the string "/demo/index" but you should force yourself to use hash format instead because
                Rails has its own way to deal with links.

        -   URL Parameters

            -   HTML link with parameters

                /demo/hello/1?page=3&name=kevin

            -   How to use Rails hash with parameters

                { :controller =? 'demo',
                  :action => 'hello',
                  :id => 1,
                  :page => 3,
                  :name => 'kevin' }

            -   Parameters hash

                Rails provides a method called params that contain all GET and POST variables 

                The hash is not regular hash, it is called HashWithIndifferentAccess

                params[:id]
                params['id']

                E.g. Assuming you are going to hit this url: http://localhost:3000/demo/hello/20?page=5

                In your controller:

                  def hello
                    @id = params['id']
                    @page = params[:page]
                  end
                
                Note: id is a special instance variable that is different from others.

                In your view:

                    ID: <%= params[:id] %> <br />
                    ID: <%= @id %> <br /> <br />
                    Next Page: <%= @page %> <br />

                Note: you can access params[:id] or via the instance variable defined in the controller.

                Also, the instance variables that store the parameters are String. So if you want to do:

                Next Page: <%= @page + 1%> <br />

                This doesn't work and you need to do like this:

                Next Page: <%= @page.to_i + 1%> <br />

                or in the controller:

                @page = params[:page].to_i


        -   Databases
                
                -   Basic DataBasic Memo

                    -   Foreign key: Table column whose values reference rows in another table
                    -   CRUD: Create, Read, Update, Delete

                -   the file /config/database.yml is used to configure the db setup

                    Rails has three different environments:

                    -   Development
                    -   Production
                    -   Test

                    These three environments are also shown in the /config/environments folder

                    You can use the command: rake db:schema:dump to dump the database

                -   rake

                    rake is a program that written in Ruby and it runs scripts known as "tasks". Similar to Unix's make program, 
                    "rake" = "ruby make"

                    E.g. rake db:schema:dump

                    By default, all the tasks that are available to run are loaded in the file: /Rakefile:

                    require File.expand_path('../config/application', __FILE__)
                    SimpleCms::Application.load_tasks

                    Also, you can add your own tasks in files placed in /lib/tasks ending in .rake.

                    -   To list all the tasks available

                        rake -T

                        To print all the db related tasks:

                        rake -T db

                    -   VARIABLE with rake

                        You can use VARIABLE for the rake command line. E.g.

                        rake db:schema:dump RAILS_ENV=production (default is RAILS_NEW=development)

                -   migration

                    migration is a set of database instructions written in Ruby. It "migrate" your database from one state to another. It contains
                    instructions for both:

                    Moving "up" to a new state
                    Moving back "down" to the previous state

                    Pro: 

                        Keeps database schema with application code
                        Executable and repeatable
                        Allows sharing schema changes
                        Helps with versioning
                        Allows writting Ruby instead of SQL

                    -   Generate migration

                        first let's look at one example:

                        rails generate migration NoNothingYet

                        After you run this comand, a new file is generated for you: e.g.  db/migrate/20141016223358_no_nothing_yet.rb

                    -   Generate a model
                        
                        rails generate model User

                        After you hit enter: You have:

                        invoke  active_record
                             create    db/migrate/20141016223930_create_users.rb
                             create    app/models/user.rb
                             invoke    test_unit
                             create      test/unit/user_test.rb
                             create      test/fixtures/users.yml

                        Note: the naming convention is Rails: model name is singular (e.g. user.rb) and the database name
                        (20141016223939_create_users.rb) is plural.

                    -   20141016223939_create_users.rb

                        class CreateUsers < ActiveRecord::Migration
                          def up
                            create_table :users do |t|
                              t.column "first_name", :string, :limit => 25
                              t.string "last_name", :limit => 25
                              t.string  "email", :default => "", :null => false
                              t.string "password", :limit => 40
                              #t.datetime "created_at"
                              #t.datetime "updated_at"
                              t.timestamps 
                            end
                          end
                          
                          def down
                            drop_table :users
                          end
                        end

                        Note: t.type name options are the shorter definition. E.g. t.string "last_name" :limit => 25
                        You can also specify the id (the indexed-increment key) to false e.g. Last but not least, 
                        t.timestamps is used to replace t.datetime "created_at" and t.datetime "updated_at"

                        def up
                            create_table :users {:id => false} do |t|
                            ...

                        -   How many Table column types available:

                            binary 
                            float 
                            boolean 
                            integer 
                            date 
                            string 
                            datetime 
                            text 
                            decimal 
                            time

                        -   How many Table column options available:

                            :limit      =>  size
                            :default    =>  value
                            :null       =>  true/false
                            :precision  =>  number
                            :scale      =>  number

                    -   Running Migration

                        rake db:migrate

                        (default is RAILS_NEW=development). After run this, you now should see the newly created tables in the database and a file 

                        /db/migrate/schema.rb is updated for this migration.

                        If you want to specify which version to bring up until:

                        rake db:migrate VERSION=#of_a_specified_version

                    -   Reversing Migration

                        rake db:migrate VERSION=0

                    -   Check Migration status

                        rake db:migrate:status

                        In summary, Running Migrations could be:

                        rake db:migrate
                        rake db:migrate VERSION=0
                        rake db:migrate VERSION=xxx
                        rake db:migrate:status
                        rake db:migrate:up VERSION=xxx
                        rake db:migrate:down VERSION=xxx
                        rake db:migrate:redo VERSION=xxx

                    -   Migration methods:

                        -   Table methods:

                            -   create_table(table, options) do |t|
                                  ...columns...
                                end

                            -   drop_table(table)

                            -   rename_table(table, new_name)

                        -   Column migration methods

                            -   add_column(table, column, type, options)
                            -   remove_column(table, column)
                            -   rename_column(table, column, new_name)
                            -   chage_column(table, column, new_name)

                        -   Index migration methods

                            -   add_index(table, column, options)
                            -   remove_index(table, column)

                        -   Index migration method options

                            -   :unique =>  true/false
                            -   :name   =>  "your_custom_name"

                        -   Execute migration method

                            -   execute("any SQL string")

                    -   Migration advice

                        -   How to fix problems if errors happen during migration?

                            Solution 1: Use SQL to fix the problems

                            Solution 2: In the problematic migration file, comment out the lines 
                            that successfuly run then fix the problematic line and run the migration again.

                        -   Migration advice

                            1)  Comment out executed code lines to get back on track. Write SQL commands as a last resort.
                            2)  Keep migrations small and concise.
                            3)  Test all migrations throughly in development.

                    -   In summary(!!):

                        The steps to create model/migration:

                        -   Design the relationships between models and determine the keys including primary keys are foreign keys
                        -   Use the command: "rails generate model xxx" to generate the migration files and model files
                        -   Run: "rake db:migrate:migrate" to generate the database tables
                        -   Check the migration status by running: rake db:migrate:

        -   ActiveRecord and ActiveRelation

            -   What is ActiveRecord?

                active record: design pattern for relational databases. It is not Rails specific.
                
                ActiveRecord: Rails implementation of active record pattern.

                This design pattern retrieves and maniplates data as objects, not as static rows.

                Active record objects are "intelligent" because it allows:

                -   Understand the structure of the table
                -   Contain data from table rows
                -   Know how to create, read, update, and delete rows
                -   Can be manipulated as objects, then saved easily

            -   Active Record Example:

                user = User.new
                user.first_name = "Kelvin"
                user.save #SQL INSERT

                user.lastname = "Skoglud"
                user.save #SQL UPDATE

                user.delete #SQL DELETE

            -   What is ActiveRelation?
                
                AKA "ARel". It's Object-oriented interpretation of relational algebra.

                It simplifies the generation of complex database queries:

                    -   Small queries are chainable (like most Ruby objects)
                    -   Complex joins and aggregations use efficient SQL
                    -   Queries do not execute until needed

                E.g.

                users = User.where(:first_name => "Kelvin")
                users = users.order("last_name" ASC).limit(5)
                users = users.include(:articles_authored)

                SELECT users.*, articles.*
                FROM users
                LEFT JOIN articles ON (users.id = 
                    articles.author_id)
                WHERE users.first_name = 'Kelvin'
                ORDER BY last_name ASC LIMIT 5

            -   Generate a Model

                -   Go to the root directory of Rails application
                    
                    e.g.
                    
                    rails generate model SingularName
                    rails generate model Subject
              
                -   Creates file in db/migrate

                    File name:  20130101000000_create_subjects.rb
                    ClassName:  CreateSubjects
                    Inherits from:  ActiveRecord::Migration
                    create_table :subjects, drop_table :subjects

                -   Creates file in app/models

                    File name:  subject.rb
                    Class name: Subject
                    Inherits from:  ActiveRecord::Base
                        
                    (!!) File names, class names, and table names matter a great deal. It is hightly recommended to stick to these
                    naming conventions. If you don't, it is still OK but you need to do some extra work. For example, if your model
                    class called "User" needs to access another table named "admin_users", you need to specify the table:

                    class User < ActiveRecord::Base
                        self.table_name = "admin_users"
                    end

                    Remember, one great feature that Rails provides for model is you don't need to write getter/setter for each column
                    because it will automatically create those getter/setter methods for you. For example, the following code don't need
                    you to write in your model class as last_name is the column in the database.

                    #long way
                    def last_name
                      @last_name
                    end
                    
                    def last_name(value)
                      @last_name = value
                    end

                    Whenever you change the column names, Rails will automatically adjust those getter/setter methdos for you.

            -   Rails Console

                Similar to irb, you can run Rails console with the following commands:

                rails console

                Note(!!): In Ubuntu 14.04, I'm getting uninitialized constant Test when running rails console in terminal. To solve this problem,
                I did this:

                sudo apt-get install ruby-test-unit
                echo require 'test/unit' >> /usr/lib/ruby/vendor_ruby/active_support/test_case.rb

                By default, Running "rails console" goes to the development environment. If you need production environment, just simply do:

                "rails console production"

                With Rails console, you can inspect models/views without a browser.

            -   Creating records

                Way 1: New/save

                    Instantiate object
                    Set values
                    Save

                Way 2: Create(all the steps above in one step!)

                    Instantiate object, set values, save

                -   Examples

                    After you run "rails console", you can run

                    -   subject = Subject.new #create a new Subject instance
                    -   subject = Subject.new(:name => "First Subject", :position => 1, :visible => true) #create a new Subject instance with some columns values set
                    -   subject.new_record? #check if the record is new or not. If it is new, it hasn't been saved to the database table yet.
                    -   subject.name = "First Subject"
                    -   subject.save
                    -   subject = Subject.create(:name => "First Subject", :position => 1, :visible => true) #create a new Subject instance with some columns values set

           -    Updating records

                Way 1: Find/save: Find record, Set values, Save

                Way 2: Find/update_attributes: Find record, Set values, save

                -   Examples

                    -   subject = Subject.find(1)
                    -   subject.new_record?
                    -   subject.name = "Initial Subject"
                    -   subject.save
                    -   subject.update_attributes(:name => "Next Subject")

            -   Deleting records

                Way 1: Find/destroy

                    -   Find record
                    -   Destroy

                Note: there is another method called delete, but it bypass some Rails features. Don't use it for now.

                -   Examples

                    -   subject.find(3)
                    -   subject.destroy

            -   Finding Records
                
                -   Primary key finder

                    Subject.find(2)
            
                    Returns an object or error

                    Note: returning error can cause problems and we prefer returning nil instead.

                -   Dynamic finders

                    Subject.find_by_id(2)

                    Returns an object or nil
                    
                    You can use dynamic finders to find entries by using other columns names rather than just the primary key.
                    For example:

                    Subject.find_by_id(2)
                    Subject.find_by_name("First Subject")

                -   Find all method

                    Subject.all

                    Returns an array of objects

                -   First/last methods

                    Subject.first, Subject.last

                    Returns an object or nil

                -   Query Methods: Conditions

                    -   where(conditions)

                        Subject.where(:visible => true)

                    -   Returns an ActiveRecord object(called ActiveRecord::Relation), which can be chained.

                        Subject.where(:visible => true).order("position ASC")

                        You can check the SQL query by using the to_sql method:

                        subject.to_sql

                    -   It does not execute a database call immediately

                    -   Condition expression types

                        -   String

                            "name = 'First Subject' AND visible = true"

                            Pro: Flexible, raw SQL

                            Con: Use carefully and between of SQL injection(??)

                            "name = '#{subject_name}' AND visible = true"
                            subject_name = "'-- hacker code --'"

                            Suggestion: should stick to hardcoded value rather than variable

                        -   Array

                            ["name = ? AND visible = true", "First Subject"]

                            Pro: Flexible, escaped SQL, safe from SQL injection

                        -   Hash

                            {:name => "First Subject", :visible => true}

                            Pro: Simple, escaped SQL, safe from SQL injection
                            Con: Only supports equality, range, and subset checking. No OR, like, less than, or greater than
                            
                            Each key-value pair is joined with AND
    
                    -   Order, Limit, Offset

                        -   Query Methods:
                    
                            -   order(sql_fragment)
                            -   limit(integer)
                            -   offset(integer)
                        
                            Example: 

                            Subject.order("position ASC").limit(20).offset(40)

                        -   Order SQL Format

                            table_name.column_name ASC/DESC

                        -   Order SQL Table Disambiguation

                            -   Not necessary for single table
                            -   Recommended with joined tables
                            -   Required when joined tables have some columns names

                                order("subject.created_at ASC")

                                order("subject.name ASC", "subjects.visible DESC")

                    -   Name Scopes

                        Format 1:

                        scope: active, lambda {where(:active => true)}

                        Format 2:

                        scope: active, -> {where(:active => true)}

                        -   Queries defined in a model
                        -   Defined using ActiveRelation query methods
                        -   Can be called like ActiveRelation methods
                        -   Can accept parameters
                        -   Rails 4 requires lambda syntax(Rails 3 is optional)
    
                        -   Examples
                                
                            1. 

                                In your class model, do this:

                                def self.active
                                    where(:active => true)
                                end

                                In your client code, do this:
            
                                Customer.active

                            2.

                                scope :with_content_type, lambda{|ctype|
                                    where(:content_type => ctype)
                                }

                                def self.with_content_type(ctype)
                                    where(:content_type => ctype)
                                end

                                Section.with_content_type('html')

                        -   Why use name scopes?

                            #Evaluate when called, not when defined

                            scope :recent, lambda {
                                where(:created_at => 1.week.go..Time.now)
                            }

                            #Chaining scopes

                            Article.recent.visible.newest_first

                        -   More examples:

                            scope :visible, lambda {where(:visible => true)}
                              scope :invisible, lambda {where(:visible => false)}
                              scope :sorted, lambda {order("subjects.position DESC")}
                              scope :newest_first, lambda {order("subjects.created_at DESC")}
                              scope :search, lambda {|query|
                                where(["name LIKE ?", "%#{query}%"]) #??the video says %% is a "present sign"? what is this?
                            }

    -   Relational database associations

        -   One-to-one

            Classroom has_one :teacher
            Teacher belongs_to :classroom

            -   scenario 1:

            Unique items a person or thing can have only one of 

            Employee has_one :office
            Student has_one :id_card    

            -   scenario 2:

            Sometimes used to break up a single table

            Customer has_one :billing_address
            Stage has_one :lighting_configuration

            For the above example, if lighting_configuration has many columns, it is wise to seperate it from Stage to avoid many columns in a
            single table.

            -   My example:

            Subject - Page

            Subject has_one :page
            Page belongs_to :subject

            !! Things to remember

            1)  Class with "belongs_to" should have the foreign key
            2)  Always define both sides of the relationship

            subject.page

            subject.page = page

            In the Subject model, do this:

            has_one :page

            In the Page mode, do this:

            belongs_to :subject

            In your client code:

            first_page = Page.new(:name => "First page", :permalink => "first", :position => 1)
            subject = Subject.find(1)
            subject.page = first_page #!!It sets the relationship between subject and first_page and saves to the database table accordingly   

            Page Load (1.4ms)  SELECT "pages".* FROM "pages" WHERE "pages"."subject_id" = 1 LIMIT 1
            => nil

            -   Remove the one-to-one relationship, do this:

            subject.page = nil #!!This doesn't remove the page entry but just removes page and subject's relationship.

            -   Delete the page entry

            subject.page.destroy

            if you run: subject.page, the page is still there but in frozen stage. For completely removes it, do:

            subject.page(true)


        -   One-to-many
    
            Teacher has_many :courses
            Course belongs_to :teacher

            -   Scenario 1:

                Used when an object has many objects which belong to it exclusively

                Photographer has_many :photographs
                Style has_many :products

                Subject has_many :pages
                Page belongs_to :subject

            -   has_many Methods:

                subject.pages #pages is an array
                subject.pages << page
                subject.pages = [page, page, page]
                subject.pages.delete(page) #remove a page. It is a Ruby array method
                subject.pages.destroy(page) #remove a page and destroy page from the database table.
                subject.pages.clear #remove all pages
                subject.pages.empty?
                subject.pages.size
                

        -   Many-to-Many

            Note: Where the foreign keys in Many-to-Many Relationship? They go in a join table?? as no table is the child of another. 

            Course has_and_belongs_to_many :students
            Student has_and_belongs_to_many :courses
            
            (When join table is simple, using only the foreign keys)

            Used when an object has many objects which belong to it but not exclusively

            project has_and_belongs_to_many :collaborators
            Blogpost has_and_belongs_to_many :categories

            It requires a join table
                Two foreign keys; index both keys together
                No primary key column (:id false)

            Same instance methods get added to the class.

            -   Example:

            AdminUser - Page

            AdminUser has_and_belongs_to_many :pages
            Page has_and_belongs_to_many :admin_users

                -   Join Table Naming

                    first_table + _ + second_table

                    Both table names are plural
                    Alphabetical order
                    Default name can be configured

                    For example: 
    
                    example 1: Project - Collaborator => collaborators_projects
                    example 2: AdminUser - Page => admin_users_pages


                -   One example: AdminUser - Page

                    Step 1: 

                    In CMD line: 

                    rails generate migration CreateAdminUsersPagesJoin


                    In the model class called AdminUser do this:

                    has_and_belongs_to_many :pages

                    In the model class called Page do this:

                    has_and_belongs_to_many :admin_users

                    Note: 

                    1)  It doesn't make any sense to add admin_users and if you want to change the name, you can do this:
                        has_and_belongs_to_many :editors, class_name => "AdminUser"

                    2)  If you don't want to follow the join table naming convention, specify the join table here e.g.

                        has_and_belongs_to_many :admin_users, join_table => "admin_user_other_pages"

                        "admin_user_other_pages" is the name of the actual table.

                    In your client code:

                    me = AdminUser.create(:first_name => "Alex", :last_name => "Yu", :username => "alexyu")
                    page = Page.find(2)
                    page.editors << me

                -   Rich join 

                    -   Why rich join?

                        -   We don't need to maintain the naming convention in the join table
                        -   Can store more info in the join table

                    -   One example: courses - students

                        Course

                            has_many :course_enrollments
                        
                        Student

                            has_many :course_entollments

                        CourseEnrollment

                            belongs_to :course
                            belongs_to :student

                    -   Compared to many-to-many simple association

                        -   Still uses a join table, with two indexed foreign keys
                        -   Requires a primary column
                        -   Join table has its own model
                        -   No table name convention to follow

                            -   Good to have: Names ending in "-ments" or "-ships" works well

                    -   One example: AdminUser - Section

                            AdminUser has_many :section_edits
                            SectionEdit belongs_to :admin_user

                            Section has_many :section_edits
                            SectionEdit belongs_to :section

                        -   Steps

                            -   Step 1: Edit the new model: SectionEdit's migration file

                            In CMD line, run: rails generate model SectionEdit. In the migration code: do:

                            class CreateSectionEdits < ActiveRecord::Migration
                              def up
                                create_table :section_edits do |t|
                                  t.references :admin_user
                                  t.references :section
                                  t.string :summary
                                  t.timestamps
                                end
                                add_index :section_edits, ["admin_user_id", "section_id"]
                              end
                              
                              def down
                                drop_table :section_edits
                              end
                            end

                            -   Step 2: Edit the model AdminUser:

                                has_many :section_edits

                            -   Step 3: Edit the model Section:

                                has_many :section_edits

                            -   Step 4: 

                                Edit the model SectionEdit

                                belongs_to :editor, :class_name => "AdminUser", :foreign_key => "admin_user_id"
                                belongs_to :section
                                
                                Note: editor is the nick name of the class AdminUser

                            -   In your client code

                                user = AdminUser.find(1)
                                section = Section.find(1)
            
                                section_edit = SectionEdit.new
                                section_edit.summary = "Test Edit"

                                section.section_edits << edit #!!Save the table section_edits automatically
                                section_edit.editor = user << !!It doesn't save the table section_edits. So you should do the following step in order to save it.
                                section_edit.save

                                user.save #!! We also need to save user as well

                                #Or you can do all of these in one step
                                SectionEdit.create(:editor => user, :section => section, :summary => "BLABLA")
                                user.section_edit(true) # Don't forget to save user
                                section.section_edit(true) #Don't forget to save section
                            
                            
                    -   Traversing a Rich Association

                            In the above example, how can we let AdminUser and Section talk to each directly? One in-direct way
                            of doing this is: 

                            section.section_edits.map {|se| se.editor}

                            [admin_user1, admin_user2]

                            -   has_many :through

                                Allow "reaching across" a rich join
                                    -   Treats rich join like an HABTM(has_and_belongs_to_many)

                                Create a functional rich join first

                            -   AdminUser - Section

                                    AdminUser has_many :section_edits
                                    AdminUser has_many :sections, :through => :section_edits
                                
                                    Section has_many :section_edits
                                    Section has_many :admin_users, :through => :section_edits

                            -   Steps

                                Step 1: In AdminUser model, add this:

                                    has_many :sections, :through => :section_edits

                                Step 2: In Section model, add this:

                                    has_many :editors, :class_name => "AdminUser", :through => :section_edits

                                Step 3: In your client code:

                                    user = AdminUser.find(1)
                                    section = Section.find(1)

                                    user.sections
                                    section.editors

                                Note:   you can try section.editors << bob but this is not recommended because you cannot not set the summary
                                        of section_editors. In some applications, this may cause problems.

-   Chapter 9 Basic CRUD

        -   Standard CRUD actions

            CRUD        Action      concept

            create      new         display new record form
            create      create      process new record form
            read        index       list records
            read        show        display a single record
            update      edit        display edit record form
            update      update      process edit record form
            delete      delete      display delete record form
            delete      destroy     process delete record form

        -   Generate new controllers

            SubjectsController, PagesController, SectionsController

        -   Often: one controller per model; user plural names

        -   Allow for clear URLs

            subjects/new, pages/new, sections/new
            subjects/edit, pages/edit, sections/edit

        -   An example:

            rails generate controller Subjects index show new edit delete

            note: "index show new edit delete" are the associated actions of the controller and they need templates(views) to show to your browser.

        -   Read Action

        -   Show Action

            -   Step 1
                    
                In your index view, add this line for example:

                <%= link_to("Show", {:action => 'show', :id => subject.id}, :class => 'action show') %>

                When the user clicks the link, it will direct the action called "show" with the id to the controller

            -   Step 2
                
                In your controller, add the following line:
    
                  def show
                    @subject = Subject.find(params[:id])
                  end

            -   Step 3

                In your show view, add html code based on the instance variable @subject

        -   Form Basics

            -   Rails/ERB vs. HTML

                Any template code that can be written with Rails/ERB can also be written with simple HTML.

            -   Easier/More poserful if you choose Rails/ERB

            -   link vs form

                links are get requests
                forms are post requests

                params variable can be used for both get requests or post requests. E,g,

                subject = Subject.new(:name => params[:name],
                                      :position => params[:position],
                                      :visible => params[Lvisible])

                There is a better way of doing the above tedidious method:

                <form action="/subjects/create" method="post">
                    <input type = "text" name="subject[name]" />
                    <input type = "text" name="subject[position]" />
                    <input type = "text" name="subject[visible]" />
                    
                    <input type="submit", name="commit" value="Create Subject">
                </form>

                Then you can access those parameters by:

                params[subject][:name]
                params[:position][:position]
                params[:position][:visible]

                params[:position] {:name => 'About us', :position => '5', :visible => '1'}

                Or you can create a subject with those parameters as well

                subject = Subject.new(params[:subject])

            -   Rails form, array of parameters 

                <% form_tag(:action => 'create') do %>
                  <% text_field_tag('subject[name]') %>
                  <% text_field_tag('subject[position]') %>
                  <% text_field_tag('subject[visible]') %>
                  
                  <% submit_tag("Create Subject") %>
                <% end %>

            -   Rails form, object-aware

                <% form_tag(:action => 'create') do %>
                  <% text_field(:subject, :name) %>
                  <% text_field(:subject, :position) %>
                  <% text_field(:subject, :visible) %>
                  
                  <% submit_tag(Create Subject) %>
                <% end %>

            -   Rails form, form_for :object

                <%  form_for(:subject, :url => {:action => 'create'}) do |f| %>
                  <% f.text_field(:name) %>
                  <% f.text_field(:position) %>
                  <% f.text_field(:visible) %>

                  <% submit_tag("Create Subject") %>
                <% end %>

        -   New Action

            -   Mass Assignment and Strong Parameters

                -   Mass Assignment

                    Rails term for passing a hash of values to an object to be assigned as attributes. E.g.

                    Subject.new(params[:subject])
                    Subject.create(params[:subject])
                    @subject.update_attribtes(params[:subject])

                    Problem arises because Hackers can change some parameters such as password of the user. Therefore when you do mass assignment,
                    it will update the password field for a specified user as well.

                -   Mass Assignment filtering

                    Rails v1-2: Blacklisting of attributes
                    Rails v3:   Whitelisting of attributes
                    Rails v4:   Strong parameters

                -   Strong Parameters

                    params.permit(:first_name, :last_name)
                    params.require(:subject) # returns :subject hash, similar to params[:subject]

                    params.require(:subject).permit(:name, :position, :visible)

        -   Create Action

            -   Create Form Processing

                -   Instantiate  a new object using form parameters
                -   Save the object
                -   If save succeeds, redirect to the index action
                -   If save fails, redisplay the form so user can fix problems

        -   Edit Action
                
                -   Create vs. Update

                    1)  params[:id]

                        New and create do not need an ID
                        Edit and update require an ID and an existing record

                    2)  Form processing

                        Create uses new and save
                        Update uses find and update_attributes

        -   Delete Action

            -   Delete and Destroy

                -   params[:id]

                    Delete and destroy require an ID and an existing record

                -   Form processing

                    Destroy uses find and destroy

                -   Delete Form?

                    Form might include
    
                    Delete confirmation
                    Warnnings
                    Display record attributes

                -   Delete action is often ommited(??)

        -   Flash Hash

            -   HTML is stateless

                -   Each request is distinct, no previous information
                -   Cookies and sessions allow data between requests

                    Sites send browser data to store in browser cookie
                    Every future browser request includes cookie data
                    Site can use data or look up information based on data

            -   Flash Hash

                -   Stores message in session data
                -   Clears old messages after every request
                -   Use for messages needed after a redirect

                flash[:notice] = "The subject was created successfully."
                flash[:error] = "You don't have enough access privileges."

        -   Challenges Objectives

            -   Generate a PagesController and SectionController
            -   Write controller actions

                -   index, show, new, create, edit, update, delete, destroy

                -   Copy the HTML from subjects templates

                    -   modify to work with the new controllers and actions
                    -   Use text_field helper for all form fields

-   Chapter 10  Layouts, partials and view helpers

    -   Rails layputs

        Rails' layout is in /app/views/layouts

-   Chapter 11  Assets

-   Chapter 12  Forms

-   Chapter 13  Data validation

-   Chapter 14  User authentication

-   Chapter 15  Improving the simple CMS

-   Chapter 16  Rest and Restful routes

    -   What is REST?

        -   REST is short for: Representational State Transfer. 
        -   Don't perform procedures. 
        -   Perform state transformation upon resources. We usually denote models as resources.

    -   Do you need to use REST?

        -   Default routes(using hashes) works just fine.

        -   REST is Rails default; optimized for it.

        -   Most professional Rails developers use REST

        -   Gives an application an API for free

        -   Provides conventions, consistent structure, and simplicity

    -   REST Paradigm Requirements

        1.  Organize code into resources

            Rails encourage one controller for each model

        2.  Learn HTTP verbs for working with resources

            Consider which CRUD actions are suited for each

        3.  Map a new URL syntax to controller actions

            Change Rails routes

        4.  Modify existing links and forms to use new URL syntax

            Learn about RESTful route helpers

    -   REST HTTP Verbs

        Use     Objective                           Usage           Multiple requests   Cache Boomark
                
        GET     Retrieve items from resource        links           yes                 yes
        POST    Create new item in resource         forms           no                  no
        PUT     Replace existing ite in resource    forms           yes                 no
        PATCH   Update existing item in resource    forms           no/yes              no
        DELETE  Delete existing item in resource    forms/links     yes                 no

    -   RESTful Routes

        #/config/routes.rb
        
        resources :subjects do
          member do
            get :delete
          end
        end

        for example:

        URL                     HTTP Verb       Action      Description
        /subjects               GET             index       show all items
        /subjects/new           GET             new         Show new form
        /subjects               POST            create      Create an item
        /subjects/:id           GET             show        Show item with :id
        /subjects/:id/edit      GET             edit        Show edit form form item with :id
        /subjects/:id           PATCH           update      Update item with :id
        /subjects/:id/delete    GET             delete      Show delete form for item with :id
        /subjects/:id           DELETE          destroy     Delete item with :id
    
        Note: to see the restful routes, type: rake routes
        
        It is acceptable to have Restful routes and basic routes in our application.

    -   REST URL Helpers
 
        URL                     HTTP Verb       Action      URL helper
        /subjects               GET             index       subjects_path
        /subjects/new           GET             new         new_subject_path
        /subjects               POST            create      subjects_path
        /subjects/:id           GET             show        subject_path(:id)
        /subjects/:id/edit      GET             edit        edit_subject_path(:id)
        /subjects/:id           PATCH           update      subject_path(:id)
        /subjects/:id/delete    GET             delete      delete_subject_path(:id)
        /subjects/:id           DELETE          destroy     subject_path(:id)

        E.g.

        <%= link_to('All Subjects', subjects_path) %>
        <%= link_to('Show Subject', subject_path(@subject.id)) %>
        <%= link_to('Edit Subject', edit_subject_path(@subject.id)) %>
        <%= link_to('Edit Subject', eidt_subject_path(@subject.id, :page => 1, :sort => 'name')) >

        -   REST form Helpers

            form_for(:subject, :url => subject_path(@subject.id), :html => { :method => :patch}) do |f|
            ...
            end


    
        

-   Chapter 17  Debugging and error handling

-   Chapter 18  Introduction more advanced topics

        
                

            

                    

            

            
                
                    

        
                            

-   Questions

    1.  =~ operator

    a = %w{ a b c d e f }
    a.select {|v| v =~ /[aeiou]/}   #=> ["a", "e"]

    ?? What does "v =~" mean here?
    
    the =~ operator matches the regular expression against a string, and it returns either the offset of the match from the string if it is found,
    otherwise nil.

    2.  %w

    %w(foo, bar) is a shortcut for ["foo", "bar"]. Meaning it's a notation to write an array of strings seperated by spaces instead of commas and without
    quotes around them.

    3.  meaning?

   <% link_to("Show", '#', :class => 'action delete') %> 

-   Naming convention in Rails

    Table: orders
    Class: Order
    File: /app/models/order.rb
    Primary Key: id
    Foreign Key: customer_id
    Link Tables: items_orders

    Controller Naming Convention

    Class: OrdersController
    File: /app/controllers/orders_controller.rb
    Layout: /app/layouts/orders.html.erb

    View Naming Convention

    Helper: /app/helpers/orders_helper.rb
    Helper Module: OrdersHelper
    Views: /app/views/orders/… (list.html.erb for example)

    Tests Naming Convention

    Unit: /test/unit/order_test.rb
    Functional: /test/functional/orders_controller_test.rb
    Fixtures: /test/fixtures/orders.yml

    Rails Generate commands Convention:

    Model               rails generate model Subject
    Controller          rails generate controller Subjects

-   Notes for my project

    1.  Install those gems

        sudo apt-get install ruby-dev
        sudo gem install carrierwave
        sudo gem install carrierwave_backgrounder
        sudo gem install houston 

    2.  Install rails

        sudo apt-get install libpq-dev (Linux)
        sudo gem install pg

        (go to the site root directory)
        sudo bundle install (Linux)

        After running all those steps, the bundler creates a file called Gemfile.lock based on the file Gemfile

        -   Notes for Mac

            Since the mac system will look at the file /usr/local/bin/pg_config when doing gem 'pg'

            Before you run: bundle install. you need to do:

            mv /usr/local/bin/pg_config /usr/local/bin/pg_config_orig
            
            PATH=$PATH:/Library/PostgreSQL/9.3/bin/ (assuming "/Library/PostgreSQL/9.3/bin/" is the path pointing you installed postgres sql's pg_config file)
            

    3.  Heroku

        -   Check your Heroku config

            Heroku config

        -   Web related commands:
            
            heroku apps:create alexyu-demo #create an app named "alexyu-demo"
            heroku open #open a a remote web service based on your latest production code
            heroku ps:scale web=1 #create 1 web process (the free user can only have one web process)
            heroku ps:scale web=0 #close all web processes

        -   Postgres related commands

            heroku run rake db:migrate              #run remote migrate
            heroku run rake db:migrate:status       #check remote migrate status
            heroku pg:info                          #check the remote postgres status   
            
        -   Git related commands

            git heroku push master

        -   Console commands

            heroku run rails console 

        -   Process related

            heroku ps
       
        -   Addon related commands

            heroku addons
